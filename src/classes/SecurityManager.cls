/**
 * Description of the class
 * <p /><p />
 * @author Nagendra Kumar Singh
 */
public class SecurityManager {

    /**
   * The header name for sending the random value generated by
   * {@link SecurityManager#generateNonce()} to the engine.
   */
    public static final String HEADER_NONCE = 'Ap-Nonce';
    /**
   * The header name for sending the configured user name to the engine.
   */
    public static final String HEADER_USER_NAME = 'Ap-Username';
    /**
   * The header name for sending the authentication token value generated by
   * {@link SecurityManager#generateAuthToken(String, String)} to the engine.
   */
    public static final String HEADER_AUTH_TOKEN = 'Ap-Authentication-Token';
    /**
   * The header name for sending the configured tenant id to the engine.
   */
    public static final String HEADER_TENANT_ID = 'Ap-Tenant-Id';
    /**
   * The authentication token digest algorithm must be SHA256.
   */
    public static final String AUTH_TOKEN_DIGEST_ALGORITHM = 'SHA-256';

    public Map<String, String> addSecurityHeaders(String userName, String tenantId) {

        Map<String, String> mapHeaders = new Map<String, String>();
        String passwordHash = generatePasswordDigest();
        String nonce = generateNonce(30);
        String authenticationToken = generateAuthToken(nonce, passwordHash);

        mapHeaders.put(HEADER_NONCE, nonce);
        mapHeaders.put(HEADER_USER_NAME, userName);
        mapHeaders.put(HEADER_AUTH_TOKEN, authenticationToken);
        mapHeaders.put(HEADER_TENANT_ID, tenantId);
        System.debug('Test this Please');

        return mapHeaders;
    }


    /**
   * A combination of current time and random integer value is used for generating one-time authentication tokens.
   * The nonce value structure is:<br/> <code>NONCE = FORMATTED_SECONDS_SINCE_EPOCH + FORMATTED_RANDOM_INTEGER</code>.
   *
   * The ceiling of the random number being requested is a base-2 number (2^100), hence it is possible
   * to generate a number that is larger than {@link SecurityManager#NONCE_RANDOM_COMPONENT_CEILING}. We therefore continue
   * discarding out-of-bounds values until a valid one is found. The likelihood
   * of generating an out-of-bounds random nonce component value more than a few times in a row is quite small.
   *
   * @return the decimal numeric string with nonce, with the time component left-padded with '0' to 12 digits and
   * the random component left-padded with '0' to 30 digits.
   * @see <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">Wikipedia Nonce Page</a>
   */
    String generateNonce(Integer len) {
        final String chars = '0123456789';
        Datetime dt = Datetime.now();
        Long lngTime = dt.getTime();
        String timeStamp = '000000000000';
        String strFirstElement = (timeStamp + lngTime / 1000).right(12);
        String randStr = '';
        while (randStr.length() < len) {
            Integer idx = Math.mod(Math.abs(Crypto.getRandomInteger()), chars.length());
            randStr += chars.substring(idx, idx + 1);
        }

        String toBeReturned = strFirstElement + randStr;
        return toBeReturned;
    }

    String generatePasswordDigest() {
        Blob objBlob = Crypto.generateDigest(AUTH_TOKEN_DIGEST_ALGORITHM, Blob.valueOf('HCSCTest@123'));
        return EncodingUtil.convertToHex(objBlob);
    }


    public String generateAuthToken(String nonce, String passwordDigest) {
        String tokenSourceString = nonce + passwordDigest;

        Blob objBlob = Crypto.generateDigest(AUTH_TOKEN_DIGEST_ALGORITHM, Blob.valueOf(tokenSourceString));
        return EncodingUtil.base64Encode(objBlob);
    }
}