/**
 * Description of the class
 * <p /><p />
 * @author Nagendra Kumar Singh
 */
public class SecurityManager {

  /**
 * The header name for sending the random value generated by
 * {@link SecurityManager#generateNonce()} to the engine.
 */
  public static final String HEADER_NONCE = 'Ap-Nonce';
  /**
 * The header name for sending the configured user name to the engine.
 */
  public static final String HEADER_USER_NAME = 'Ap-Username';
  /**
 * The header name for sending the authentication token value generated by
 * {@link SecurityManager#generateAuthToken(String, String)} to the engine.
 */
  public static final String HEADER_AUTH_TOKEN = 'Ap-Authentication-Token';
  /**
 * The header name for sending the configured tenant id to the engine.
 */
  public static final String HEADER_TENANT_ID = 'Ap-Tenant-Id';
  /**
 * The authentication token digest algorithm must be SHA256.
 */
  public static final String AUTH_TOKEN_DIGEST_ALGORITHM = 'SHA-256';

  public Map<String, String> addSecurityHeaders(String userName, String tenantId) {

    Map<String, String> mapHeaders = new Map<String, String>();
    String passwordHash = generatePasswordDigest();
    String nonce = generateNonce(30);
    String authenticationToken = generateAuthToken(nonce, passwordHash);

    mapHeaders.put(HEADER_NONCE, nonce);
    mapHeaders.put(HEADER_USER_NAME, userName);
    mapHeaders.put(HEADER_AUTH_TOKEN, authenticationToken);
    mapHeaders.put(HEADER_TENANT_ID, tenantId);
    System.debug('Test this Please');

    return mapHeaders;
  }


  /**
 * A combination of current time and random integer value is used for generating one-time authentication tokens.
 * The nonce value structure is:<br/> <code>NONCE = FORMATTED_SECONDS_SINCE_EPOCH + FORMATTED_RANDOM_INTEGER</code>.
 *
 * The ceiling of the random number being requested is a base-2 number (2^100), hence it is possible
 * to generate a number that is larger than {@link SecurityManager#NONCE_RANDOM_COMPONENT_CEILING}. We therefore continue
 * discarding out-of-bounds values until a valid one is found. The likelihood
 * of generating an out-of-bounds random nonce component value more than a few times in a row is quite small.
 *
 * @return the decimal numeric string with nonce, with the time component left-padded with '0' to 12 digits and
 * the random component left-padded with '0' to 30 digits.
 * @see <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">Wikipedia Nonce Page</a>
 */
  String generateNonce(Integer len) {
    final String chars = '0123456789';
    Datetime dt = Datetime.now();
    Long lngTime = dt.getTime();
    String timeStamp = '000000000000';
    String strFirstElement = (timeStamp + lngTime/1000).right(12);
    String randStr = '';
    while (randStr.length() < len) {
      Integer idx = Math.mod(Math.abs(Crypto.getRandomInteger()), chars.length());
      randStr += chars.substring(idx, idx+1);
    }

    String toBeReturned = strFirstElement + randStr;
    return toBeReturned;
  }

  String generatePasswordDigest(){
    Blob objBlob = Crypto.generateDigest(AUTH_TOKEN_DIGEST_ALGORITHM, Blob.valueOf('HCSCTest@123'));
    return EncodingUtil.convertToHex(objBlob);
  }


  public String generateAuthToken(String nonce, String passwordDigest) {
    String tokenSourceString = nonce + passwordDigest;

    Blob objBlob = Crypto.generateDigest(AUTH_TOKEN_DIGEST_ALGORITHM, Blob.valueOf(tokenSourceString));
    return EncodingUtil.base64Encode(objBlob);
  }
}